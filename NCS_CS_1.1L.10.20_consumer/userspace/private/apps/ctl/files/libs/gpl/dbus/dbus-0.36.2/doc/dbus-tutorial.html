<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>D-BUS Tutorial</title><meta name="generator" content="DocBook XSL Stylesheets V1.69.1"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="article" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="index"></a>D-BUS Tutorial</h1></div><div><div class="authorgroup"><div class="author"><h3 class="author"><span class="firstname">Havoc</span> <span class="surname">Pennington</span></h3><div class="affiliation"><span class="orgname">Red Hat, Inc.<br></span><div class="address"><p><br>
	    <code class="email">&lt;<a href="mailto:hp@pobox.com">hp@pobox.com</a>&gt;</code><br>
	  </p></div></div></div><div class="author"><h3 class="author"><span class="firstname">David</span> <span class="surname">Wheeler</span></h3></div><div class="author"><h3 class="author"><span class="firstname">John</span> <span class="surname">Palmieri</span></h3><div class="affiliation"><span class="orgname">Red Hat, Inc.<br></span><div class="address"><p><br>
	    <code class="email">&lt;<a href="mailto:johnp@redhat.com">johnp@redhat.com</a>&gt;</code><br>
	  </p></div></div></div><div class="author"><h3 class="author"><span class="firstname">Colin</span> <span class="surname">Walters</span></h3><div class="affiliation"><span class="orgname">Red Hat, Inc.<br></span><div class="address"><p><br>
	    <code class="email">&lt;<a href="mailto:walters@redhat.com">walters@redhat.com</a>&gt;</code><br>
	  </p></div></div></div></div></div><div><p class="releaseinfo">Version 0.4.1</p></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#whatis">What is D-BUS?</a></span></dt><dd><dl><dt><span class="sect2"><a href="#uses">D-BUS applications</a></span></dt></dl></dd><dt><span class="sect1"><a href="#concepts">Concepts</a></span></dt><dd><dl><dt><span class="sect2"><a href="#objects">Objects and Object Paths</a></span></dt><dt><span class="sect2"><a href="#interfaces">Interfaces</a></span></dt><dt><span class="sect2"><a href="#messages">Message Types</a></span></dt><dt><span class="sect2"><a href="#bus-names">Bus Names</a></span></dt><dt><span class="sect2"><a href="#addresses">Addresses</a></span></dt><dt><span class="sect2"><a href="#bigpicture">Big Conceptual Picture</a></span></dt></dl></dd><dt><span class="sect1"><a href="#glib-client">GLib API: Using Remote Objects</a></span></dt><dd><dl><dt><span class="sect2"><a href="#glib-typemappings">D-BUS - GLib type mappings</a></span></dt><dt><span class="sect2"><a href="#sample-program-1">A sample program</a></span></dt><dt><span class="sect2"><a href="#glib-program-setup">Program initalization</a></span></dt><dt><span class="sect2"><a href="#glib-method-invocation">Understanding method invocation</a></span></dt><dt><span class="sect2"><a href="#glib-signal-connection">Connecting to object signals</a></span></dt><dt><span class="sect2"><a href="#glib-error-handling">Error handling and remote exceptions</a></span></dt><dt><span class="sect2"><a href="#glib-more-examples">More examples of method invocation</a></span></dt></dl></dd><dt><span class="sect1"><a href="#glib-server">GLib API: Implementing Objects</a></span></dt><dt><span class="sect1"><a href="#python-client">Python API: Using Remote Objects</a></span></dt><dd><dl><dt><span class="sect2"><a href="#python-typemappings">D-BUS - Python type mappings</a></span></dt><dt><span class="sect2"><a href="#python-invoking-methods">Invoking Methods</a></span></dt><dt><span class="sect2"><a href="#python-listening-for-signals">Listening for Signals</a></span></dt></dl></dd><dt><span class="sect1"><a href="#python-server">Python API: Implementing Objects</a></span></dt><dd><dl><dt><span class="sect2"><a href="#python-inheriting-from-dbus-object">Inheriting From dbus.service.Object</a></span></dt><dt><span class="sect2"><a href="#python-exporting-methods">Exporting Methods Over The Bus</a></span></dt><dt><span class="sect2"><a href="#python-emitting-signals">Emitting Signals</a></span></dt><dt><span class="sect2"><a href="#python-inheriting-and-overriding">Inheriting from HelloWorldObject</a></span></dt><dt><span class="sect2"><a href="#python-conclusion">Conclusion</a></span></dt></dl></dd><dt><span class="sect1"><a href="#qt-client">Qt API: Using Remote Objects</a></span></dt><dt><span class="sect1"><a href="#qt-server">Qt API: Implementing Objects</a></span></dt></dl></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="whatis"></a>What is D-BUS?</h2></div></div></div><p>
      D-BUS is a system for <em class="firstterm">interprocess communication</em>
      (IPC). Architecturally, it has several layers:

      </p><div class="itemizedlist"><ul type="disc"><li><p>
            A library, <em class="firstterm">libdbus</em>, that allows two
            applications to connect to each other and exchange messages.
          </p></li><li><p>
            A <em class="firstterm">message bus daemon</em> executable, built on
            libdbus, that multiple applications can connect to. The daemon can
            route messages from one application to zero or more other
            applications.
          </p></li><li><p>
            <em class="firstterm">Wrapper libraries</em> based on particular
            application frameworks.  For example, libdbus-glib and
            libdbus-qt. There are also bindings to languages such as
            Python. These wrapper libraries are the API most people should use,
            as they simplify the details of D-BUS programming. libdbus is 
            intended to be a low-level backend for the higher level bindings.
            Much of the libdbus API is only useful for binding implementation.
          </p></li></ul></div><p>
    </p><p>
      If you just want to use D-BUS and don't care how it works, jump directly
      to <a href="#concepts" title="Concepts">the section called &#8220;Concepts&#8221;</a>.
      Otherwise, read on.
    </p><p>
      libdbus only supports one-to-one connections, just like a raw network
      socket. However, rather than sending byte streams over the connection, you
      send <em class="firstterm">messages</em>. Messages have a header identifying
      the kind of message, and a body containing a data payload. libdbus also
      abstracts the exact transport used (sockets vs. whatever else), and
      handles details such as authentication.
    </p><p>
      The message bus daemon forms the hub of a wheel. Each spoke of the wheel
      is a one-to-one connection to an application using libdbus.  An
      application sends a message to the bus daemon over its spoke, and the bus
      daemon forwards the message to other connected applications as
      appropriate. Think of the daemon as a router.
    </p><p>
      The bus daemon has multiple instances on a typical computer.  The
      first instance is a machine-global singleton, that is, a system daemon
      similar to sendmail or Apache. This instance has heavy security
      restrictions on what messages it will accept, and is used for systemwide
      communication. The other instances are created one per user login session.
      These instances allow applications in the user's session to communicate 
      with one another.
    </p><p>
      The systemwide and per-user daemons are separate.  Normal within-session
      IPC does not involve the systemwide message bus process and vice versa.
    </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="uses"></a>D-BUS applications</h3></div></div></div><p>
        There are many, many technologies in the world that have "Inter-process
        communication" or "networking" in their stated purpose: <a href="http://www.omg.org" target="_top">CORBA</a>, <a href="http://www.opengroup.org/dce/" target="_top">DCE</a>, <a href="http://www.microsoft.com/com/" target="_top">DCOM</a>, <a href="http://developer.kde.org/documentation/library/kdeqt/dcop.html" target="_top">DCOP</a>, <a href="http://www.xmlrpc.com" target="_top">XML-RPC</a>, <a href="http://www.w3.org/TR/SOAP/" target="_top">SOAP</a>, <a href="http://www.mbus.org/" target="_top">MBUS</a>, <a href="http://www.zeroc.com/ice.html" target="_top">Internet Communications Engine (ICE)</a>,
        and probably hundreds more.
        Each of these is tailored for particular kinds of application.
        D-BUS is designed for two specific cases:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
              Communication between desktop applications in the same desktop
              session; to allow integration of the desktop session as a whole,
              and address issues of process lifecycle (when do desktop components 
              start and stop running).
            </p></li><li><p>
              Communication between the desktop session and the operating system, 
              where the operating system would typically include the kernel 
              and any system daemons or processes.
            </p></li></ul></div><p>
      </p><p>
        For the within-desktop-session use case, the GNOME and KDE desktops 
        have significant previous experience with different IPC solutions
        such as CORBA and DCOP. D-BUS is built on that experience and 
        carefully tailored to meet the needs of these desktop projects 
        in particular. D-BUS may or may not be appropriate for other 
        applications; the FAQ has some comparisons to other IPC systems.
      </p><p>
        The problem solved by the systemwide or communication-with-the-OS case 
        is explained well by the following text from the Linux Hotplug project:
        </p><div class="blockquote"><blockquote class="blockquote"><p>
           A gap in current Linux support is that policies with any sort of
           dynamic "interact with user" component aren't currently
           supported. For example, that's often needed the first time a network
           adapter or printer is connected, and to determine appropriate places
           to mount disk drives. It would seem that such actions could be
           supported for any case where a responsible human can be identified:
           single user workstations, or any system which is remotely
           administered.
          </p><p>
            This is a classic "remote sysadmin" problem, where in this case
            hotplugging needs to deliver an event from one security domain
            (operating system kernel, in this case) to another (desktop for
            logged-in user, or remote sysadmin). Any effective response must go
            the other way: the remote domain taking some action that lets the
            kernel expose the desired device capabilities. (The action can often
            be taken asynchronously, for example letting new hardware be idle
            until a meeting finishes.) At this writing, Linux doesn't have
            widely adopted solutions to such problems. However, the new D-Bus
            work may begin to solve that problem.
          </p></blockquote></div><p>
      </p><p>
        D-BUS may happen to be useful for purposes other than the one it was
        designed for. Its general properties that distinguish it from 
        other forms of IPC are:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
              Binary protocol designed to be used asynchronously 
              (similar in spirit to the X Window System protocol).
            </p></li><li><p>
              Stateful, reliable connections held open over time.
            </p></li><li><p>
              The message bus is a daemon, not a "swarm" or 
              distributed architecture.
            </p></li><li><p>
              Many implementation and deployment issues are specified rather
              than left ambiguous.
            </p></li><li><p>
              Semantics are similar to the existing DCOP system, allowing 
              KDE to adopt it more easily.
            </p></li><li><p>
              Security features to support the systemwide mode of the 
              message bus.
            </p></li></ul></div><p>
      </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="concepts"></a>Concepts</h2></div></div></div><p>
      Some basic concepts apply no matter what application framework you're
      using to write a D-BUS application. The exact code you write will be
      different for GLib vs. Qt vs. Python applications, however.
    </p><p>
      Here is a diagram (<a href="diagram.png" target="_top">png</a> <a href="diagram.svg" target="_top">svg</a>) that may help you visualize the concepts
      that follow.
    </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="objects"></a>Objects and Object Paths</h3></div></div></div><p>
        Each application using D-BUS contains <em class="firstterm">objects</em>,
        which generally map to GObject, QObject, C++ objects, or Python objects
        (but need not).  An object is an <span class="emphasis"><em>instance</em></span> rather
        than a type.  When messages are received over a D-BUS connection, they
        are sent to a specific object, not to the application as a whole.
      </p><p>
        To allow messages to specify their destination object, there has to be a
        way to refer to an object. In your favorite programming language, this
        is normally called a <em class="firstterm">pointer</em> or
        <em class="firstterm">reference</em>. However, these references are
        implemented as memory addresses relative to the address space of your
        application, and thus can't be passed from one application to another.
      </p><p>
        To solve this, D-BUS introduces a name for each object. The name 
        looks like a filesystem path, for example an object could be 
        named <code class="literal">/org/kde/kspread/sheets/3/cells/4/5</code>. 
        Human-readable paths are nice, but you are free to create an 
        object named <code class="literal">/com/mycompany/c5yo817y0c1y1c5b</code> 
        if it makes sense for your application.
      </p><p>
        Namespacing object paths is smart, by starting them with the components
        of a domain name you own (e.g. <code class="literal">/org/kde</code>). This 
        keeps different code modules in the same process from stepping 
        on one another's toes.
      </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="interfaces"></a>Interfaces</h3></div></div></div><p>
        Each object supports one or more <em class="firstterm">interfaces</em>.
        Think of an interface as a named group of methods and signals, 
        just as it is in GLib or Qt or Java. Interfaces define the 
        <span class="emphasis"><em>type</em></span> of an object instance.
      </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="messages"></a>Message Types</h3></div></div></div><p>
        Messages are not all the same; in particular, D-BUS has 
        4 built-in message types:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
              Method call messages ask to invoke a method 
              on an object.
            </p></li><li><p>
              Method return messages return the results 
              of invoking a method.
            </p></li><li><p>
              Error messages return an exception caused by 
              invoking a method.
            </p></li><li><p>
              Signal messages are notifications that a given signal 
              has been emitted (that an event has occurred). 
              You could also think of these as "event" messages.
            </p></li></ul></div><p>
      </p><p>
        A method call maps very simply to messages, then: you send a method call
        message, and receive either a method return message or an error message
        in reply.
      </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="bus-names"></a>Bus Names</h3></div></div></div><p>
        Object paths, interfaces, and messages exist on the level of 
        libdbus and the D-BUS protocol; they are used even in the 
        1-to-1 case with no message bus involved.
      </p><p>
        Bus names, on the other hand, are a property of the message bus daemon.
        The bus maintains a mapping from names to message bus connections.
        These names are used to specify the origin and destination
        of messages passing through the message bus. When a name is mapped 
        to a particular application's connection, that application is said to 
        <em class="firstterm">own</em> that name.
      </p><p>
        On connecting to the bus daemon, each application immediately owns a
        special name called the <em class="firstterm">unique connection name</em>.
        A unique name begins with a ':' (colon) character; no other names are
        allowed to begin with that character. Unique names are special because
        they are created dynamically, and are never re-used during the lifetime
        of the same bus daemon. You know that a given unique name will have the
        same owner at all times.  An example of a unique name might be
        <code class="literal">:34-907</code>. The numbers after the colon have 
        no meaning other than their uniqueness.
      </p><p>
        Applications may ask to own additional <em class="firstterm">well-known
        names</em>. For example, you could write a specification to
        define a name called <code class="literal">com.mycompany.TextEditor</code>.
        Your definition could specify that to own this name, an application
        should have an object at the path
        <code class="literal">/com/mycompany/TextFileManager</code> supporting the
        interface <code class="literal">org.freedesktop.FileHandler</code>.        
      </p><p>
        Applications could then send messages to this bus name, 
        object, and interface to execute method calls.
      </p><p>
        You could think of the unique names as IP addresses, and the
        well-known names as domain names. So
        <code class="literal">com.mycompany.TextEditor</code> might map to something like
        <code class="literal">:34-907</code> just as <code class="literal">mycompany.com</code> maps
        to something like <code class="literal">192.168.0.5</code>.
      </p><p>
        Names have a second important use, other than routing messages.  They
        are used to track lifecycle. When an application exits (or crashes), its
        connection to the message bus will be closed by the operating system
        kernel. The message bus then sends out notification messages telling
        remaining applications that the application's names have lost their
        owner. By tracking these notifications, your application can reliably
        monitor the lifetime of other applications.
      </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="addresses"></a>Addresses</h3></div></div></div><p>
        Applications using D-BUS are either servers or clients.  A server
        listens for incoming connections; a client connects to a server. Once
        the connection is established, it is a symmetric flow of messages; the
        client-server distinction only matters when setting up the 
        connection.
      </p><p>
        A D-BUS <em class="firstterm">address</em> specifies where a server will
        listen, and where a client will connect.  For example, the address
        <code class="literal">unix:path=/tmp/abcdef</code> specifies that the server will
        listen on a UNIX domain socket at the path
        <code class="literal">/tmp/abcdef</code> and the client will connect to that
        socket. An address can also specify TCP/IP sockets, or any other
        transport defined in future iterations of the D-BUS specification.
      </p><p>
        When using D-BUS with a message bus, the bus daemon is a server 
        and all other applications are clients of the bus daemon.
        libdbus automatically discovers the address of the per-session bus 
        daemon by reading an environment variable. It discovers the 
        systemwide bus daemon by checking a well-known UNIX domain socket path
        (though you can override this address with an environment variable).
      </p><p>
        If you're using D-BUS without a bus daemon, it's up to you to 
        define which application will be the server and which will be 
        the client, and specify a mechanism for them to agree on 
        the server's address.
      </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="bigpicture"></a>Big Conceptual Picture</h3></div></div></div><p>
        Pulling all these concepts together, to specify a particular 
        method call on a particular object instance, a number of 
        nested components have to be named:
        </p><pre class="programlisting">
          Address -&gt; [Bus Name] -&gt; Path -&gt; Interface -&gt; Method
        </pre><p>
        The bus name is in brackets to indicate that it's optional -- you only
        provide a name to route the method call to the right application
        when using the bus daemon. If you have a direct connection to another
        application, bus names aren't used; there's no bus daemon.
      </p><p>
        The interface is also optional, primarily for historical 
        reasons; DCOP does not require specifying the interface, 
        instead simply forbidding duplicate method names 
        on the same object instance. D-BUS will thus let you 
        omit the interface, but if your method name is ambiguous 
        it is undefined which method will be invoked.
      </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="glib-client"></a>GLib API: Using Remote Objects</h2></div></div></div><p>
      The GLib binding is defined in the header file
      &lt;dbus/dbus-glib.h&gt;.
    </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="glib-typemappings"></a>D-BUS - GLib type mappings</h3></div></div></div><p>
	The heart of the GLib bindings for D-BUS is the mapping it
	provides between D-BUS "type signatures" and GLib types
	(<code class="literal">GType</code>). The D-BUS type system is composed of
	a number of "basic" types, along with several "container" types.
      </p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="glib-basic-typemappings"></a>Basic type mappings</h4></div></div></div><p>
	  Below is a list of the basic types, along with their associated
	  mapping to a <code class="literal">GType</code>.
	  </p><div class="informaltable"><table border="1"><colgroup><col><col><col><col></colgroup><thead><tr><th>D-BUS basic type</th><th>GType</th><th>Free function</th><th>Notes</th></tr></thead><tbody><tr><td><code class="literal">BYTE</code></td><td><code class="literal">G_TYPE_UCHAR</code></td><td> </td><td> </td></tr><tr><td><code class="literal">BOOLEAN</code></td><td><code class="literal">G_TYPE_BOOLEAN</code></td><td> </td><td> </td></tr><tr><td><code class="literal">INT16</code></td><td><code class="literal">G_TYPE_INT</code></td><td> </td><td>Will be changed to a G_TYPE_INT16 once GLib has it</td></tr><tr><td><code class="literal">UINT16</code></td><td><code class="literal">G_TYPE_UINT</code></td><td> </td><td>Will be changed to a G_TYPE_UINT16 once GLib has it</td></tr><tr><td><code class="literal">INT32</code></td><td><code class="literal">G_TYPE_INT</code></td><td> </td><td>Will be changed to a G_TYPE_INT32 once GLib has it</td></tr><tr><td><code class="literal">UINT32</code></td><td><code class="literal">G_TYPE_UINT</code></td><td> </td><td>Will be changed to a G_TYPE_UINT32 once GLib has it</td></tr><tr><td><code class="literal">INT64</code></td><td><code class="literal">G_TYPE_GINT64</code></td><td> </td><td> </td></tr><tr><td><code class="literal">UINT64</code></td><td><code class="literal">G_TYPE_GUINT64</code></td><td> </td><td> </td></tr><tr><td><code class="literal">DOUBLE</code></td><td><code class="literal">G_TYPE_DOUBLE</code></td><td> </td><td> </td></tr><tr><td><code class="literal">STRING</code></td><td><code class="literal">G_TYPE_STRING</code></td><td>g_free</td><td> </td></tr><tr><td><code class="literal">OBJECT_PATH</code></td><td><code class="literal">DBUS_TYPE_G_PROXY</code></td><td>g_object_unref</td><td>The returned proxy does not have an interface set; use <code class="literal">dbus_g_proxy_set_interface</code> to invoke methods</td></tr></tbody></table></div><p>
	  As you can see, the basic mapping is fairly straightforward.
	</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="glib-container-typemappings"></a>Container type mappings</h4></div></div></div><p>
	  The D-BUS type system also has a number of "container"
	  types, such as <code class="literal">DBUS_TYPE_ARRAY</code> and
	  <code class="literal">DBUS_TYPE_STRUCT</code>.  The D-BUS type system
	  is fully recursive, so one can for example have an array of
	  array of strings (i.e. type signature
	  <code class="literal">aas</code>).
	</p><p>
	  However, not all of these types are in common use; for
	  example, at the time of this writing the author knows of no
	  one using <code class="literal">DBUS_TYPE_STRUCT</code>, or a
	  <code class="literal">DBUS_TYPE_ARRAY</code> containing any non-basic
	  type.  The approach the GLib bindings take is pragmatic; try
	  to map the most common types in the most obvious way, and
	  let using less common and more complex types be less
	  "natural".
	</p><p>
	  First, D-BUS type signatures which have an "obvious"
	  corresponding builtin GLib type are mapped using that type:
	  </p><div class="informaltable"><table border="1"><colgroup><col><col><col><col><col><col></colgroup><thead><tr><th>D-BUS type signature</th><th>Description</th><th>GType</th><th>C typedef</th><th>Free function</th><th>Notes</th></tr></thead><tbody><tr><td><code class="literal">as</code></td><td>Array of strings</td><td><code class="literal">G_TYPE_STRV</code></td><td><code class="literal">char **</code></td><td>g_strfreev</td><td> </td></tr><tr><td><code class="literal">v</code></td><td>Generic value container</td><td><code class="literal">G_TYPE_VALUE</code></td><td><code class="literal">GValue *</code></td><td>g_value_unset</td><td>The calling conventions for values expect that method callers have allocated return values; see below.</td></tr></tbody></table></div><p>
	</p><p>
	  The next most common recursive type signatures are arrays of
	  basic values.  The most obvious mapping for arrays of basic
	  types is a <code class="literal">GArray</code>.  Now, GLib does not
	  provide a builtin <code class="literal">GType</code> for
	  <code class="literal">GArray</code>.  However, we actually need more than
	  that - we need a "parameterized" type which includes the
	  contained type.  Why we need this we will see below.
	</p><p>
	  The approach taken is to create these types in the D-BUS GLib
	  bindings; however, there is nothing D-BUS specific about them.
	  In the future, we hope to include such "fundamental" types in GLib
	  itself.
	  </p><div class="informaltable"><table border="1"><colgroup><col><col><col><col><col><col></colgroup><thead><tr><th>D-BUS type signature</th><th>Description</th><th>GType</th><th>C typedef</th><th>Free function</th><th>Notes</th></tr></thead><tbody><tr><td><code class="literal">ay</code></td><td>Array of bytes</td><td><code class="literal">DBUS_TYPE_G_BYTE_ARRAY</code></td><td><code class="literal">GArray *</code></td><td>g_array_free</td><td> </td></tr><tr><td><code class="literal">au</code></td><td>Array of uint</td><td><code class="literal">DBUS_TYPE_G_UINT_ARRAY</code></td><td><code class="literal">GArray *</code></td><td>g_array_free</td><td> </td></tr><tr><td><code class="literal">ai</code></td><td>Array of int</td><td><code class="literal">DBUS_TYPE_G_INT_ARRAY</code></td><td><code class="literal">GArray *</code></td><td>g_array_free</td><td> </td></tr><tr><td><code class="literal">ax</code></td><td>Array of int64</td><td><code class="literal">DBUS_TYPE_G_INT64_ARRAY</code></td><td><code class="literal">GArray *</code></td><td>g_array_free</td><td> </td></tr><tr><td><code class="literal">at</code></td><td>Array of uint64</td><td><code class="literal">DBUS_TYPE_G_UINT64_ARRAY</code></td><td><code class="literal">GArray *</code></td><td>g_array_free</td><td> </td></tr><tr><td><code class="literal">ad</code></td><td>Array of double</td><td><code class="literal">DBUS_TYPE_G_DOUBLE_ARRAY</code></td><td><code class="literal">GArray *</code></td><td>g_array_free</td><td> </td></tr><tr><td><code class="literal">ab</code></td><td>Array of boolean</td><td><code class="literal">DBUS_TYPE_G_BOOLEAN_ARRAY</code></td><td><code class="literal">GArray *</code></td><td>g_array_free</td><td> </td></tr></tbody></table></div><p>
	</p><p>
	  D-BUS also includes a special type DBUS_TYPE_DICT_ENTRY which
	  is only valid in arrays.  It's intended to be mapped to a "dictionary"
	  type by bindings.  The obvious GLib mapping here is GHashTable.  Again,
	  however, there is no builtin <code class="literal">GType</code> for a GHashTable.
	  Moreover, just like for arrays, we need a parameterized type so that
	  the bindings can communiate which types are contained in the hash table.
	</p><p>
	  At present, only strings are supported.  Work is in progress to
	  include more types.
	  </p><div class="informaltable"><table border="1"><colgroup><col><col><col><col><col><col></colgroup><thead><tr><th>D-BUS type signature</th><th>Description</th><th>GType</th><th>C typedef</th><th>Free function</th><th>Notes</th></tr></thead><tbody><tr><td><code class="literal">a{ss}</code></td><td>Dictionary mapping strings to strings</td><td><code class="literal">DBUS_TYPE_G_STRING_STRING_HASHTABLE</code></td><td><code class="literal">GHashTable *</code></td><td>g_hash_table_destroy</td><td> </td></tr></tbody></table></div><p>
	</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="glib-generic-typemappings"></a>Arbitrarily recursive type mappings</h4></div></div></div><p>
	  Finally, it is possible users will want to write or invoke D-BUS
	  methods which have arbitrarily complex type signatures not
	  directly supported by these bindings.  For this case, we have a
	  <code class="literal">DBusGValue</code> which acts as a kind of special
	  variant value which may be iterated over manually.  The
	  <code class="literal">GType</code> associated is
	  <code class="literal">DBUS_TYPE_G_VALUE</code>.
	</p><p>
	  TODO insert usage of <code class="literal">DBUS_TYPE_G_VALUE</code> here.
	</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="sample-program-1"></a>A sample program</h3></div></div></div><p>Here is a D-BUS program using the GLib bindings.
</p><pre class="programlisting">      
int
main (int argc, char **argv)
{
  DBusGConnection *connection;
  GError *error;
  DBusGProxy *proxy;
  char **name_list;
  char **name_list_ptr;
  
  g_type_init ();

  error = NULL;
  connection = dbus_g_bus_get (DBUS_BUS_SESSION,
                               &amp;error);
  if (connection == NULL)
    {
      g_printerr ("Failed to open connection to bus: %s\n",
                  error-&gt;message);
      g_error_free (error);
      exit (1);
    }

  /* Create a proxy object for the "bus driver" (name "org.freedesktop.DBus") */
  
  proxy = dbus_g_proxy_new_for_name (connection,
                                     DBUS_SERVICE_DBUS,
                                     DBUS_PATH_DBUS,
                                     DBUS_INTERFACE_DBUS);

  /* Call ListNames method, wait for reply */
  error = NULL;
  if (!dbus_g_proxy_call (proxy, "ListNames", &amp;error, G_TYPE_INVALID,
                          G_TYPE_STRV, &amp;name_list, G_TYPE_INVALID))
    {
      /* Just do demonstrate remote exceptions versus regular GError */
      if (error-&gt;domain == DBUS_GERROR &amp;&amp; error-&gt;code == DBUS_GERROR_REMOTE_EXCEPTION)
        g_printerr ("Caught remote method exception %s: %s",
	            dbus_g_error_get_name (error),
	            error-&gt;message);
      else
        g_printerr ("Error: %s\n", error-&gt;message);
      g_error_free (error);
      exit (1);
    }

  /* Print the results */
 
  g_print ("Names on the message bus:\n");
  
  for (name_list_ptr = name_list; *name_list_ptr; name_list_ptr++)
    {
      g_print ("  %s\n", *name_list_ptr);
    }
  g_strfreev (name_list);

  g_object_unref (proxy);

  return 0;
}
</pre><p>
    </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="glib-program-setup"></a>Program initalization</h3></div></div></div><p>
	A connection to the bus is acquired using
	<code class="literal">dbus_g_bus_get</code>.  Next, a proxy
	is created for the object "/org/freedesktop/DBus" with
	interface <code class="literal">org.freedesktop.DBus</code>
	on the service <code class="literal">org.freedesktop.DBus</code>.
	This is a proxy for the message bus itself.
      </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="glib-method-invocation"></a>Understanding method invocation</h3></div></div></div><p>
	You have a number of choices for method invocation.  First, as
	used above, <code class="literal">dbus_g_proxy_call</code> sends a
	method call to the remote object, and blocks until reply is
	recieved.  The outgoing arguments are specified in the varargs
	array, terminated with <code class="literal">G_TYPE_INVALID</code>.
	Next, pointers to return values are specified, followed again
	by <code class="literal">G_TYPE_INVALID</code>.
      </p><p>
	To invoke a method asynchronously, use
	<code class="literal">dbus_g_proxy_begin_call</code>.  This returns a
	<code class="literal">DBusGPendingCall</code> object; you may then set a
	notification function using
	<code class="literal">dbus_g_pending_call_set_notify</code>.
      </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="glib-signal-connection"></a>Connecting to object signals</h3></div></div></div><p>
	You may connect to signals using
	<code class="literal">dbus_g_proxy_add_signal</code> and
	<code class="literal">dbus_g_proxy_connect_signal</code>.  You must
	invoke <code class="literal">dbus_g_proxy_add_signal</code> to specify
	the signature of your signal handlers; you may then invoke
	<code class="literal">dbus_g_proxy_connect_signal</code> multiple times.
      </p><p>
	Note that it will often be the case that there is no builtin
	marshaller for the type signature of a remote signal.  In that
	case, you must generate a marshaller yourself by using
	<span class="application">glib-genmarshal</span>, and then register
	it using <code class="literal">dbus_g_object_register_marshaller</code>.
      </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="glib-error-handling"></a>Error handling and remote exceptions</h3></div></div></div><p>
	All of the GLib binding methods such as
	<code class="literal">dbus_g_proxy_end_call</code> return a
	<code class="literal">GError</code>.  This <code class="literal">GError</code> can
	represent two different things:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
	    An internal D-BUS error, such as an out-of-memory
	    condition, an I/O error, or a network timeout.  Errors
	    generated by the D-BUS library itself have the domain
	    <code class="literal">DBUS_GERROR</code>, and a corresponding code
	    such as <code class="literal">DBUS_GERROR_NO_MEMORY</code>.  It will
	    not be typical for applications to handle these errors
	    specifically.
	  </p></li><li><p>
	    A remote D-BUS exception, thrown by the peer, bus, or
	    service.  D-BUS remote exceptions have both a textual
	    "name" and a "message".  The GLib bindings store this
	    information in the <code class="literal">GError</code>, but some
	    special rules apply.
	  </p><p>
	    The set error will have the domain
	    <code class="literal">DBUS_GERROR</code> as above, and will also
	    have the code
	    <code class="literal">DBUS_GERROR_REMOTE_EXCEPTION</code>.  In order
	    to access the remote exception name, you must use a
	    special accessor, such as
	    <code class="literal">dbus_g_error_has_name</code> or
	    <code class="literal">dbus_g_error_get_name</code>.  The remote
	    exception detailed message is accessible via the regular
	    GError <code class="literal">message</code> member.
	  </p></li></ul></div><p>
      </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="glib-more-examples"></a>More examples of method invocation</h3></div></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="glib-sending-stuff"></a>Sending an integer and string, receiving an array of bytes</h4></div></div></div><p>
</p><pre class="programlisting">
  GArray *arr;
  
  error = NULL;
  if (!dbus_g_proxy_call (proxy, "Foobar", &amp;error,
                          G_TYPE_INT, 42, G_TYPE_STRING, "hello",
			  G_TYPE_INVALID,
			  DBUS_TYPE_G_UCHAR_ARRAY, &amp;arr, G_TYPE_INVALID))
    {
      /* Handle error */
    }
   g_assert (arr != NULL);
   printf ("got back %u values", arr-&gt;len);
</pre><p>
	</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="glib-sending-hash"></a>Sending a GHashTable</h4></div></div></div><p>
</p><pre class="programlisting">
  GHashTable *hash = g_hash_table_new (g_str_hash, g_str_equal);
  guint32 ret;
  
  g_hash_table_insert (hash, "foo", "bar");
  g_hash_table_insert (hash, "baz", "whee");

  error = NULL;
  if (!dbus_g_proxy_call (proxy, "HashSize", &amp;error,
                          DBUS_TYPE_G_STRING_STRING_HASH, hash, G_TYPE_INVALID,
			  G_TYPE_UINT, &amp;ret, G_TYPE_INVALID))
    {
      /* Handle error */
    }
  g_assert (ret == 2);
  g_hash_table_destroy (hash);
</pre><p>
	</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="glib-receiving-bool-int"></a>Receiving a boolean and a string</h4></div></div></div><p>
</p><pre class="programlisting">
  gboolean boolret;
  char *strret;
  
  error = NULL;
  if (!dbus_g_proxy_call (proxy, "GetStuff", &amp;error,
			  G_TYPE_INVALID,
                          G_TYPE_BOOLEAN, &amp;boolret,
                          G_TYPE_STRING, &amp;strret,
			  G_TYPE_INVALID))
    {
      /* Handle error */
    }
  printf ("%s %s", boolret ? "TRUE" : "FALSE", strret);
  g_free (strret);
</pre><p>
	</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="glib-sending-str-arrays"></a>Sending two arrays of strings</h4></div></div></div><p>
</p><pre class="programlisting">
  /* NULL terminate */
  char *strs_static[] = {"foo", "bar", "baz", NULL};
  /* Take pointer to array; cannot pass array directly */
  char **strs_static_p = strs_static;
  char **strs_dynamic;

  strs_dynamic = g_new (char *, 4);
  strs_dynamic[0] = g_strdup ("hello");
  strs_dynamic[1] = g_strdup ("world");
  strs_dynamic[2] = g_strdup ("!");
  /* NULL terminate */
  strs_dynamic[3] = NULL;
  
  error = NULL;
  if (!dbus_g_proxy_call (proxy, "TwoStrArrays", &amp;error,
                          G_TYPE_STRV, strs_static_p,
                          G_TYPE_STRV, strs_dynamic,
			  G_TYPE_INVALID,
			  G_TYPE_INVALID))
    {
      /* Handle error */
    }
   g_strfreev (strs_dynamic);
</pre><p>
	</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="glib-getting-str-array"></a>Sending a boolean, receiving an array of strings</h4></div></div></div><p>
</p><pre class="programlisting">
  char **strs;
  char **strs_p;
  gboolean blah;

  error = NULL;
  blah = TRUE;
  if (!dbus_g_proxy_call (proxy, "GetStrs", &amp;error,
                          G_TYPE_BOOLEAN, blah,
			  G_TYPE_INVALID,
                          G_TYPE_STRV, &amp;strs,
			  G_TYPE_INVALID))
    {
      /* Handle error */
    }
   for (strs_p = strs; *strs_p; strs_p++)
     printf ("got string: \"%s\"", *strs_p);
   g_strfreev (strs);
</pre><p>
	</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="glib-sending-variant"></a>Sending a variant</h4></div></div></div><p>
</p><pre class="programlisting">
  GValue val = {0, };

  g_value_init (&amp;val, G_TYPE_STRING);
  g_value_set_string (&amp;val, "hello world");
  
  error = NULL;
  if (!dbus_g_proxy_call (proxy, "SendVariant", &amp;error,
                          G_TYPE_VALUE, &amp;val, G_TYPE_INVALID,
			  G_TYPE_INVALID))
    {
      /* Handle error */
    }
  g_assert (ret == 2);
  g_value_unset (&amp;val);
</pre><p>
	</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="glib-receiving-variant"></a>Receiving a variant</h4></div></div></div><p>
</p><pre class="programlisting">
  GValue val = {0, };

  error = NULL;
  if (!dbus_g_proxy_call (proxy, "GetVariant", &amp;error, G_TYPE_INVALID,
                          G_TYPE_VALUE, &amp;val, G_TYPE_INVALID))
    {
      /* Handle error */
    }
  if (G_VALUE_TYPE (&amp;val) == G_TYPE_STRING)
    printf ("%s\n", g_value_get_string (&amp;val));
  else if (G_VALUE_TYPE (&amp;val) == G_TYPE_INT)
    printf ("%d\n", g_value_get_int (&amp;val));
  else
    ...
  g_value_unset (&amp;val);
</pre><p>
	</p></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="glib-server"></a>GLib API: Implementing Objects</h2></div></div></div><p>
      At the moment, to expose a GObject via D-BUS, you must
      write XML by hand which describes the methods exported
      by the object.  In the future, this manual step will
      be obviated by the upcoming GLib introspection support.
    </p><p>
      Here is a sample XML file which describes an object that exposes
      one method, named <code class="literal">ManyArgs</code>.
</p><pre class="programlisting">
&lt;?xml version="1.0" encoding="UTF-8" ?&gt;

&lt;node name="/com/example/MyObject"&gt;

  &lt;interface name="com.example.MyObject"&gt;
    &lt;annotation name="org.freedesktop.DBus.GLib.CSymbol" value="my_object"/&gt;
    &lt;method name="ManyArgs"&gt;
      &lt;!-- This is optional, and in this case is redunundant --&gt;
      &lt;annotation name="org.freedesktop.DBus.GLib.CSymbol" value="my_object_many_args"/&gt;
      &lt;arg type="u" name="x" direction="in" /&gt;
      &lt;arg type="s" name="str" direction="in" /&gt;
      &lt;arg type="d" name="trouble" direction="in" /&gt;
      &lt;arg type="d" name="d_ret" direction="out" /&gt;
      &lt;arg type="s" name="str_ret" direction="out" /&gt;
    &lt;/method&gt;
  &lt;/interface&gt;
&lt;/node&gt;
</pre><p>
    </p><p>
      This XML is in the same format as the D-BUS introspection XML
      format. Except we must include an "annotation" which give the C
      symbols corresponding to the object implementation prefix
      (<code class="literal">my_object</code>).  In addition, if particular
      methods symbol names deviate from C convention
      (i.e. <code class="literal">ManyArgs</code> -&gt;
      <code class="literal">many_args</code>), you may specify an annotation
      giving the C symbol.
    </p><p>
      Once you have written this XML, run <code class="literal">dbus-binding-tool --mode=glib-server <em class="replaceable"><code>FILENAME</code></em> &gt; <em class="replaceable"><code>HEADER_NAME</code></em>.</code> to
      generate a header file.  For example: <span><strong class="command">dbus-binding-tool --mode=glib-server my-objet.xml &gt; my-object-glue.h</strong></span>.
    </p><p>
      Next, include the generated header in your program, and invoke
      <code class="literal">dbus_g_object_class_install_info</code>, passing the
      object class and "object info" included in the header.  For
      example:
      </p><pre class="programlisting">
	dbus_g_object_type_install_info (COM_FOO_TYPE_MY_OBJECT, &amp;com_foo_my_object_info);
      </pre><p>
      This should be done exactly once per object class.
    </p><p>
      To actually implement the method, just define a C function named e.g.
      <code class="literal">my_object_many_args</code> in the same file as the info
      header is included.  At the moment, it is required that this function
      conform to the following rules:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
	    The function must return a value of type <code class="literal">gboolean</code>;
	    <code class="literal">TRUE</code> on success, and <code class="literal">FALSE</code>
	    otherwise.
	  </p></li><li><p>
	    The first parameter is a pointer to an instance of the object.
	  </p></li><li><p>
	    Following the object instance pointer are the method
	    input values.
	  </p></li><li><p>
	    Following the input values are pointers to return values.
	  </p></li><li><p>
	    The final parameter must be a <code class="literal">GError **</code>.
	    If the function returns <code class="literal">FALSE</code> for an
	    error, the error parameter must be initalized with
	    <code class="literal">g_set_error</code>.
	  </p></li></ul></div><p>
    </p><p>
      Finally, you can export an object using <code class="literal">dbus_g_connection_register_g_object</code>.  For example:
      </p><pre class="programlisting">
	  dbus_g_connection_register_g_object (connection,
                                               "/com/foo/MyObject",
                                               obj);
      </pre><p>
    </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="python-client"></a>Python API: Using Remote Objects</h2></div></div></div><p>
      The Python bindings provide a simple to use interface for talking over D-BUS.
      Where possible much of the inner-workings of D-BUS are hidden behind what looks
      like normal Python objects.
    </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="python-typemappings"></a>D-BUS - Python type mappings</h3></div></div></div><p>
        While python itself is a largely untyped language D-BUS provides a simple type system
        for talking with other languages which may be strongly typed.  Python for the most part
        tries automatically map python objects to types on the bus.  It is none the less good to 
        know what the type mappings are so one can better utilize services over the bus.
      </p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="python-basic-typemappings"></a>Basic type mappings</h4></div></div></div><p>
	  Below is a list of the basic types, along with their associated
	  mapping to a Python object.
	  </p><div class="informaltable"><table border="1"><colgroup><col><col><col></colgroup><thead><tr><th>D-BUS basic type</th><th>Python wrapper</th><th>Notes</th></tr></thead><tbody><tr><td><code class="literal">BYTE</code></td><td><code class="literal">dbus.Byte</code></td><td> </td></tr><tr><td><code class="literal">BOOLEAN</code></td><td><code class="literal">dbus.Boolean</code></td><td>Any variable assigned a True or False boolean value will automatically be converted into a BOOLEAN over the bus</td></tr><tr><td><code class="literal">INT16</code></td><td><code class="literal">dbus.Int16</code></td><td> </td></tr><tr><td><code class="literal">UINT16</code></td><td><code class="literal">dbus.UInt16</code></td><td> </td></tr><tr><td><code class="literal">INT32</code></td><td><code class="literal">dbus.Int32</code></td><td>This is the default mapping for Python integers</td></tr><tr><td><code class="literal">UINT32</code></td><td><code class="literal">dbus.UInt32</code></td><td> </td></tr><tr><td><code class="literal">INT64</code></td><td><code class="literal">dbus.Int64</code></td><td> </td></tr><tr><td><code class="literal">UINT64</code></td><td><code class="literal">dbus.UInt64</code></td><td> </td></tr><tr><td><code class="literal">DOUBLE</code></td><td><code class="literal">dbus.Double</code></td><td>Any variable assigned a floating point number will automatically be converted into a DOUBLE over the bus</td></tr><tr><td><code class="literal">STRING</code></td><td><code class="literal">dbus.String</code></td><td>Any variable assigned a quoted string will automatically be converted into a STRING over the bus</td></tr><tr><td><code class="literal">OBJECT_PATH</code></td><td><code class="literal">dbus.ObjectPath</code></td><td> </td></tr></tbody></table></div><p>
	</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="python-container-typemappings"></a>Container type mappings</h4></div></div></div><p>
	  The D-BUS type system also has a number of "container"
	  types, such as <code class="literal">DBUS_TYPE_ARRAY</code> and
	  <code class="literal">DBUS_TYPE_STRUCT</code>.  The D-BUS type system
	  is fully recursive, so one can for example have an array of
	  array of strings (i.e. type signature
	  <code class="literal">aas</code>).
	</p><p>
	  D-BUS container types have native corresponding built-in Python types
	  so it is easy to use them.
	  </p><div class="informaltable"><table border="1"><colgroup><col><col><col></colgroup><thead><tr><th>D-BUS type</th><th>Python type</th><th>Python wrapper</th><th>Notes</th></tr></thead><tbody><tr><td><code class="literal">ARRAY</code></td><td><code class="literal">Python lists</code></td><td><code class="literal">dbus.Array</code></td><td>Python lists, denoted by square brackets [], are converted into arrays and visa versa.
		  The one restriction is that when sending a Python list each element of the list must be of the same
		  type.  This is because D-BUS arrays can contain only one element type.  Use Python tuples for mixed types.
                  
                  When using the wrapper you may also specify a type or signature of the elements contained in the Array.
                  This is manditory when passing an empty Array to a method on the bus because Python can not guess at the 
                  contents of an empty array.  For example if a method is expecting an Array of int32's and you need to pass
                  it an empty Array you would do it as such:
                  
                  <pre class="programlisting">emptyint32array = dbus.Array([], type=dbus.Int32)</pre>

                  or

                  <pre class="programlisting">emptyint32array = dbus.Array([], signature="i")</pre>

                  Note that dbus.Array derives from list so it acts just like a python list.
                  </td></tr><tr><td><code class="literal">STRUCT</code></td><td><code class="literal">Python tuple</code></td><td><code class="literal">dbus.Struct</code></td><td>Python tuples, denoted by parentheses (,), are converted into structs and visa versa.
		  Tuples can have mixed types.</td></tr><tr><td><code class="literal">DICTIONARY</code></td><td><code class="literal">Python dictionary</code></td><td><code class="literal">dbus.Dictionary</code></td><td>D-BUS doesn't have an explicit dictionary type.  Instead it uses LISTS of DICT_ENTRIES to
		  represent a dictionary.  A DICT_ENTRY is simply a two element struct containing a key/value pair.
		  Python dictionaries are automatically converted to a LIST of DICT_ENTRIES and visa versa.
                  
                  Since dictonaries are described as lists of dict_entries we also need the signature in order
                  to pass empty dictionaries.  The wrapper provides a way of specifying this through the key_type/value_type
                  type parameters or the signature parameters.  To send an empty Dictionary where the key is a string
                  and the value is a string you would do it as such:
                  
                  <pre class="programlisting">emptystringstringdict = dbus.Dictionary({}, key_type=dbus.String, value_type=dbus.Value)</pre>

                  or

                  <pre class="programlisting">emptystringstringdict = dbus.Dictionary({}, signature="ss")</pre>
        
                  Note that dbus.Dictionary derives from dict so it acts just like a python dictionary.
                  </td></tr><tr><td><code class="literal">VARIANT</code></td><td><code class="literal">any type</code></td><td><code class="literal">dbus.Variant</code></td><td>A variant is a container for any type.  Python exports its methods to accept only variants 
		   since we are an untyped language and can demarshal into any Python type.
                   
                   To send a variant you must first wrap it in a<code class="literal">dbus.Variant</code>.  If no type or signiture is 
                   given to the variant the marshaler will get the type from the contents.</td></tr></tbody></table></div><p>
	</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="python-invoking-methods"></a>Invoking Methods</h3></div></div></div><p>Here is a D-BUS program using the Python bindings to get a listing of all names on the session bus.
</p><pre class="programlisting">      
import dbus

bus = dbus.SessionBus()
proxy_obj = bus.bus.get_object('org.freedesktop.DBus', '/org/freedesktop/DBus')
dbus_iface = dbus.Interface(proxy_obj, 'org.freedesktop.DBus')

print dbus_iface.ListNames()
</pre><p>
      </p><p>
        Notice I get an interface on the proxy object and use that to make the call.  While the specifications
	state that you do not need to specify an interface if the call is unambiguous (i.e. only one method implements
	that name) due to a bug on the bus that drops messages which don't have an interface field you need to specify
	interfaces at this time.  In any event it is always good practice to specify the interface of the method you 
	wish to call to avoid any side effects should a method of the same name be implemented on another interface.
      </p><p>
        You can specify the interface for a single call using the dbus_interface keyword.
</p><pre class="programlisting">
proxy_obj.ListNames(dbus_interface = 'org.freedesktop.DBus')
</pre><p>
      </p><p>
        This is all fine and good if all you want to do is call methods on the bus and then exit.  In order to 
        do more complex things such as use a GUI or make asynchronous calls you will need a mainloop.  You would use
	asynchronous calls because in GUI applications it is very bad to block for any long period of time.  This cause
	the GUI to seem to freeze.  Since replies to D-BUS messages can take an indeterminate amount of time using async 
	calls allows you to return control to the GUI while you wait for the reply.  This is exceedingly easy to do in
	Python.  Here is an example using the GLib/GTK+ mainloop.
</p><pre class="programlisting">
import gobject 
import dbus
if getattr(dbus, 'version', (0,0,0)) &gt;= (0,41,0):
    import dbus.glib

def print_list_names_reply(list):
    print str(list) 

def print_error(e):
    print str(e)
    
bus = dbus.SessionBus()
proxy_obj = bus.bus.get_object('org.freedesktop.DBus', '/org/freedesktop/DBus')
dbus_iface = dbus.Interface(proxy_obj, 'org.freedesktop.DBus')

dbus_iface.ListNames(reply_handler=print_list_names_reply, error_handler=print_error)

mainloop = gobject.MainLoop()
mainloop.run()
</pre><p>
      </p><p>
        In the above listing you will notice the reply_handler and error_handler keywords.  These tell the method that
	it should be called async and to call print_list_names_reply or print_error depending if you get a reply or an error.
	The signature for replys depends on the number of arguments being sent back.  Error handlers always take one parameter
	which is the error object returned.
      </p><p>
        You will also notice that I check the version of the dbus bindings before importing dbus.glib.  In older versions
	glib was the only available mainloop.  As of version 0.41.0 we split out the glib dependency to allow for other mainloops
	to be implemented.  Notice also the python binding version does not match up with the D-BUS version.  Once we reach 1.0
	this should change with Python changes simply tracking the D-BUS changes.
        While the glib mainloop is the only mainloop currently implemented, integrating other mainloops should
	be very easy to do.  There are plans for creating a a generic mainloop to be the default for non gui programs.
      </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="python-listening-for-signals"></a>Listening for Signals</h3></div></div></div><p>
        Signals are emitted by objects on the bus to notify listening programs that an event has occurred.  There are a couple of ways
        to register a signal handler on the bus.  One way is to attach to an already created proxy using the connect_to_signal method
	which takes a signal name and handler as arguments.  Let us look at an example of connecting to the HAL service to receive
	signals when devices are added and removed and when devices register a capability.  This example assumes you have HAL already running.
</p><pre class="programlisting">
import gobject 
import dbus
if getattr(dbus, 'version', (0,0,0)) &gt;= (0,41,0):
    import dbus.glib

def device_added_callback(udi):
    print 'Device with udi %s was added' % (udi)

def device_removed_callback(udi):
    print 'Device with udi %s was added' % (udi)

def device_capability_callback(udi, capability):
    print 'Device with udi %s added capability %s' % (udi, capability)

bus = dbus.SystemBus()
hal_manager_obj = bus.get_object('org.freedesktop.Hal', 
                                 '/org/freedesktop/Hal/Manager')
hal_manager = dbus.Interface(hal_manager_obj,
                             'org.freedesktop.Hal.Manager')

hal_manager.connect_to_signal('DeviceAdded', device_added_callback)
hal_manager.connect_to_signal('DeviceRemoved', device_removed_callback)
hal_manager.connect_to_signal('NewCapability', device_capability_callback)

mainloop = gobject.MainLoop()
mainloop.run()
</pre><p>
      </p><p>
        The drawback of using this method is that the service that you are connecting to has to be around when you register
	your signal handler.  While HAL is guaranteed to be around on systems that use it this is not always the case for every
	service on the bus.  Say our program started up before HAL, we could connect to the signal by adding a signal receiver
	directly to the bus.
</p><pre class="programlisting">
bus.add_signal_receiver(device_added_callback,
                        'DeviceAdded',
                        'org.freedesktop.Hal.Manager',
                        'org.freedesktop.Hal',
                        '/org/freedesktop/Hal/Manager')

bus.add_signal_receiver(device_removed_callback,
                        'DeviceRemoved',
                        'org.freedesktop.Hal.Manager',
                        'org.freedesktop.Hal',
                        '/org/freedesktop/Hal/Manager')

bus.add_signal_receiver(device_capability_callback,
                        'DeviceAdded',
                        'org.freedesktop.Hal.Manager',
                        'org.freedesktop.Hal',
                        '/org/freedesktop/Hal/Manager')
</pre><p>
      </p><p>
        All this can be done without creating the proxy object if one wanted to but in most cases you would want to have 
	a reference to the object so once a signal was received operations could be executed on the object.
      </p><div class="sidebar"><p class="title"><b>Signal matching on arguments</b></p><p>
          Starting with D-Bus 0.36 and the (0, 43, 0) version of the python 
          bindings you can now add a match on arguments being sent in a signal.
          This is useful for instance for only getting NameOwnerChanged
          signals for your service.  Lets say we create a name on the bus called
          'org.foo.MyName' we could also add a match to just get 
          NameOwnerChanges for that name as such:
</p><pre class="programlisting">
bus.add_signal_receiver(myname_changed,
                        'NameOwnerChanged',
                        'org.freedesktop.DBus',
                        'org.freedesktop.DBus',
                        '/org/freedesktop/DBus',
                        arg0='org.foo.MyName')
</pre><p>

          It is as simple as that.  To match the second arg you would use arg1=,
          the third arg2=, etc.
        </p></div><div class="sidebar"><p class="title"><b>Cost of Creating a Proxy Object</b></p><p>
	  Note that creating proxy objects can have an associated processing cost.  When introspection is implemented
	  a proxy may wait for introspection data before processing any requests.  It is generally good practice to
	  create proxies once and reuse the proxy when calling into the object.  Constantly creating the same proxy 
	  over and over again can become a bottleneck for your program.
	</p></div><p>
        TODO: example of getting information about devices from HAL
      </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="python-server"></a>Python API: Implementing Objects</h2></div></div></div><p>
      Implementing object on the bus is just as easy as invoking methods or listening for signals on the bus.
    </p><div class="sidebar"><p class="title"><b>Version Alert</b></p><p>
        The Python D-BUS bindings require version 2.4 or greater of Python when creating D-BUS objects.
      </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="python-inheriting-from-dbus-object"></a>Inheriting From dbus.service.Object</h3></div></div></div><p>
        In order to export a Python object over the bus one must first get a bus name and then create
        a Python object that inherits from dbus.service.Object.  The following is the start of an example
	HelloWorld object that we want to export over the session bus.
</p><pre class="programlisting">
import gobject 
import dbus
import dbus.service
if getattr(dbus, 'version', (0,0,0)) &gt;= (0,41,0):
    import dbus.glib

class HelloWorldObject(dbus.service.Object):
    def __init__(self, bus_name, object_path='/org/freedesktop/HelloWorldObject'):
        dbus.service.Object.__init__(self, bus_name, object_path)

session_bus = dbus.SessionBus()
bus_name = dbus.service.BusName('org.freedesktop.HelloWorld', bus=session_bus)
object = HelloWorldObject(bus_name)

mainloop = gobject.MainLoop()
mainloop.run()
</pre><p>
      </p><p>
        Here we got the session bus, then created a BusName object which requests a name on the bus.
	We pass that bus name to the HelloWorldObject object which inherits from dbus.service.Object.
	We now have an object on the bus but it is pretty useless.
      </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="python-exporting-methods"></a>Exporting Methods Over The Bus</h3></div></div></div><p>
        Let's make this object do something and export a method over the bus.
</p><pre class="programlisting">
import gobject
import dbus
import dbus.service
if getattr(dbus, 'version', (0,0,0)) &gt;= (0,41,0):
    import dbus.glib

class HelloWorldObject(dbus.service.Object):
    def __init__(self, bus_name, object_path='/org/freedesktop/HelloWorldObject'):
        dbus.service.Object.__init__(self, bus_name, object_path)

    @dbus.service.method('org.freedesktop.HelloWorldIFace')
    def hello(self):
        return 'Hello from the HelloWorldObject'
      
session_bus = dbus.SessionBus()
bus_name = dbus.service.BusName('org.freedesktop.HelloWorld', bus=session_bus)
object = HelloWorldObject(bus_name)

mainloop = gobject.MainLoop()
mainloop.run()
</pre><p>
      </p><div class="sidebar"><p class="title"><b>Python Decorators</b></p><p>
	  Notice the @ symbol on the line before the hello method.  This is a new directive introduced in
	  Python 2.4.  It is called a decorator and it "decorates" methods.  All you have to know is that
	  it provides metadata that can then be used to alter the behavior of the method being decorated.
	  In this case we are telling the bindings that the hello method should be exported as a D-BUS method
	  over the bus.
	</p></div><p>
        As you can see we exported the hello method as part of the org.freedesktop.HelloWorldIFace interface.
	It takes no arguments and returns a string to the calling program. Let's create a proxy and invoke this
	method.
</p><pre class="programlisting">      
import dbus

bus = dbus.SessionBus()
proxy_obj = bus.bus.get_object('org.freedesktop.HelloWorld', '/org/freedesktop/HelloWorldObject')
iface = dbus.Interface(proxy_obj, 'org.freedesktop.HelloWorldIFace')

print iface.hello()
</pre><p>
      </p><p>
        When invoking methods exported over the bus the bindings automatically know how many parameters
	the method exports.  You can even make a method that exports an arbitrary number of parameters.
	Also, whatever you return will automatically be transfered as a reply over the bus. Some examples.
</p><pre class="programlisting">
    @dbus.service.method('org.freedesktop.HelloWorldIFace')
    def one_arg(self, first_arg):
        return 'I got arg %s' % first_arg
      
    @dbus.service.method('org.freedesktop.HelloWorldIFace')
    def two_args(self, first_arg, second_arg):
        return ('I got 2 args', first_arg, second_arg)

    @dbus.service.method('org.freedesktop.HelloWorldIFace')
    def return_list(self):
        return [1, 2, 3, 4, 5, 6]
    
    @dbus.service.method('org.freedesktop.HelloWorldIFace')
    def return_dict(self):
        return {one: '1ne', two: '2wo', three: '3ree'}
</pre><p>
      </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="python-emitting-signals"></a>Emitting Signals</h3></div></div></div><p>
        Setting up signals to emit is just as easy as exporting methods.  It uses the same syntax as methods.
</p><pre class="programlisting">
import gobject
import dbus
import dbus.service
if getattr(dbus, 'version', (0,0,0)) &gt;= (0,41,0):
    import dbus.glib

class HelloWorldObject(dbus.service.Object):
    def __init__(self, bus_name, object_path='/org/freedesktop/HelloWorldObject'):
        dbus.service.Object.__init__(self, bus_name, object_path)

    @dbus.service.method('org.freedesktop.HelloWorldIFace')
    def hello(self):
        return 'Hello from the HelloWorldObject'
      
    @dbus.service.signal('org.freedesktop.HelloWorldIFace')
    def hello_signal(self, message):
        pass
	
session_bus = dbus.SessionBus()
bus_name = dbus.service.BusName('org.freedesktop.HelloWorld', bus=session_bus)
object = HelloWorldObject(bus_name)

object.hello_signal('I sent a hello signal')

mainloop = gobject.MainLoop()
mainloop.run()
</pre><p>
      </p><p>
        Adding a @dbus.service.signal decorator to a method turns it into a signal emitter.  You can put code
	in this method to do things like keep track of how many times you call the emitter or to print out debug
	messages but for the most part a pass noop will do.  Whenever you call the emitter a signal will be emitted
	with the parameters you passed in as arguments.  In the above example we send the message 'I sent a hello signal'
	with the signal.
      </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="python-inheriting-and-overriding"></a>Inheriting from HelloWorldObject</h3></div></div></div><p>
        One of the cool things you can do in Python is inherit from another D-BUS object.  We use this trick in
	the bindings to provide a default implementation for the org.freedesktop.DBus.Introspectable interface.
	Let's inherit from the HelloWorldObject example above and overide the hello method to say goodbye.
</p><pre class="programlisting">
class HelloWorldGoodbyeObject(HelloWorldObject):
    def __init__(self, bus_name, object_path='/org/freedesktop/HelloWorldGoodbyeObject'):
        HelloWorldObject.__init__(self, bus_name, object_path)

    @dbus.service.method('org.freedesktop.HelloWorldGoodbyeIFace')
    def hello(self):
        return 'Goodbye'

goodbye_object = HelloWorldGoodbyeObject(bus_name)
</pre><p>
      </p><p>
       Let's now call both methods with a little help from interfaces.
</p><pre class="programlisting">      
import dbus

bus = dbus.SessionBus()
proxy_obj = bus.bus.get_object('org.freedesktop.HelloWorld', '/org/freedesktop/HelloWorldGoodbyeObject')

print proxy_obj.hello(dbus_interface='org.freedesktop.HelloWorldIFace')
print proxy_obj.hello(dbus_interface='org.freedesktop.HelloWorldGoodbyeIFace')
</pre><p>
      </p><p>
        This should print out 'Hello from the HelloWorldObject' followed by a 'Goodbye'.
      </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="python-conclusion"></a>Conclusion</h3></div></div></div><p>
        As you can see, using D-BUS from Python is an extremely easy proposition.  Hopefully
	the tutorial has been helpful in getting you started.  If you need anymore help please
	feel free to post on the <a href="http://lists.freedesktop.org/mailman/listinfo/dbus/" target="_top">mailing list</a>.
	The Python bindings are still in a state of flux and there may be API changes in the future.
	This tutorial will be updated if such changes occur.
      </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="qt-client"></a>Qt API: Using Remote Objects</h2></div></div></div><p>
      
      The Qt bindings are not yet documented.

    </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="qt-server"></a>Qt API: Implementing Objects</h2></div></div></div><p>
      The Qt bindings are not yet documented.
    </p></div></div></body></html>
